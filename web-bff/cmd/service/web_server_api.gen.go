// Package main provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.7.0 DO NOT EDIT.
package main

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	externalRef0 "github.com/stackus/ftgogo/serviceapis/commonapi"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for OrderState.
const (
	OrderStateApprovalPending OrderState = "ApprovalPending"

	OrderStateApproved OrderState = "Approved"

	OrderStateCancelPending OrderState = "CancelPending"

	OrderStateCancelled OrderState = "Cancelled"

	OrderStateRejected OrderState = "Rejected"

	OrderStateRevisionPending OrderState = "RevisionPending"

	OrderStateUnknown OrderState = "Unknown"
)

// Order defines model for Order.
type Order struct {
	OrderId    string     `json:"order_id"`
	OrderTotal int        `json:"order_total"`
	State      OrderState `json:"state"`
}

// OrderHistory defines model for OrderHistory.
type OrderHistory struct {
	CreatedAt      *time.Time `json:"created_at,omitempty"`
	OrderId        string     `json:"order_id"`
	RestaurantId   string     `json:"restaurant_id"`
	RestaurantName string     `json:"restaurant_name"`
	Status         string     `json:"status"`
}

// OrderState defines model for OrderState.
type OrderState string

// ConsumerAddressID defines model for ConsumerAddressID.
type ConsumerAddressID string

// LimitQuery defines model for LimitQuery.
type LimitQuery int

// NextQuery defines model for NextQuery.
type NextQuery string

// OrderID defines model for OrderID.
type OrderID string

// RestaurantID defines model for RestaurantID.
type RestaurantID string

// ConsumerAddressIDResponse defines model for ConsumerAddressIDResponse.
type ConsumerAddressIDResponse struct {
	AddressId  string `json:"address_id"`
	ConsumerId string `json:"consumer_id"`
}

// ConsumerAddressResponse defines model for ConsumerAddressResponse.
type ConsumerAddressResponse struct {
	Address externalRef0.Address `json:"address"`
}

// ConsumerIDResponse defines model for ConsumerIDResponse.
type ConsumerIDResponse struct {
	Id string `json:"id"`
}

// ConsumerResponse defines model for ConsumerResponse.
type ConsumerResponse struct {
	ConsumerId string `json:"consumer_id"`
	Name       string `json:"name"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Message string `json:"message"`
}

// OrderIDResponse defines model for OrderIDResponse.
type OrderIDResponse struct {
	Id string `json:"id"`
}

// OrderResponse defines model for OrderResponse.
type OrderResponse struct {
	Order Order `json:"order"`
}

// OrderStatusResponse defines model for OrderStatusResponse.
type OrderStatusResponse struct {
	Status OrderState `json:"status"`
}

// RestaurantIDResponse defines model for RestaurantIDResponse.
type RestaurantIDResponse struct {
	Id string `json:"id"`
}

// SearchOrderHistoriesResponse defines model for SearchOrderHistoriesResponse.
type SearchOrderHistoriesResponse struct {
	Next   string         `json:"next"`
	Orders []OrderHistory `json:"orders"`
}

// SignInResponse defines model for SignInResponse.
type SignInResponse struct {
	Token string `json:"token"`
}

// AddConsumerAddressJSONBody defines parameters for AddConsumerAddress.
type AddConsumerAddressJSONBody struct {
	Address externalRef0.Address `json:"address"`
	Name    string               `json:"name"`
}

// UpdateConsumerAddressJSONBody defines parameters for UpdateConsumerAddress.
type UpdateConsumerAddressJSONBody struct {
	Address externalRef0.Address `json:"address"`
}

// CreateOrderJSONBody defines parameters for CreateOrder.
type CreateOrderJSONBody struct {
	AddressId    string                          `json:"address_id"`
	ConsumerId   string                          `json:"consumer_id"`
	LineItems    externalRef0.MenuItemQuantities `json:"line_items"`
	RestaurantId string                          `json:"restaurant_id"`
}

// SearchOrderHistoriesParams defines parameters for SearchOrderHistories.
type SearchOrderHistoriesParams struct {

	// search filters
	Filter *struct {
		Keywords *[]string   `json:"keywords,omitempty"`
		Since    *time.Time  `json:"since,omitempty"`
		Status   *OrderState `json:"status,omitempty"`
	} `json:"filter,omitempty"`

	// provide to read the next page of results
	Next *NextQuery `json:"next,omitempty"`

	// provide to set the results page size
	Limit *LimitQuery `json:"limit,omitempty"`
}

// ReviseOrderJSONBody defines parameters for ReviseOrder.
type ReviseOrderJSONBody struct {
	RevisedQuantities externalRef0.MenuItemQuantities `json:"revised_quantities"`
}

// RegisterConsumerJSONBody defines parameters for RegisterConsumer.
type RegisterConsumerJSONBody struct {
	Name string `json:"name"`
}

// SignInConsumerJSONBody defines parameters for SignInConsumer.
type SignInConsumerJSONBody struct {
	ConsumerId string `json:"consumer_id"`
}

// AddConsumerAddressJSONRequestBody defines body for AddConsumerAddress for application/json ContentType.
type AddConsumerAddressJSONRequestBody AddConsumerAddressJSONBody

// UpdateConsumerAddressJSONRequestBody defines body for UpdateConsumerAddress for application/json ContentType.
type UpdateConsumerAddressJSONRequestBody UpdateConsumerAddressJSONBody

// CreateOrderJSONRequestBody defines body for CreateOrder for application/json ContentType.
type CreateOrderJSONRequestBody CreateOrderJSONBody

// ReviseOrderJSONRequestBody defines body for ReviseOrder for application/json ContentType.
type ReviseOrderJSONRequestBody ReviseOrderJSONBody

// RegisterConsumerJSONRequestBody defines body for RegisterConsumer for application/json ContentType.
type RegisterConsumerJSONRequestBody RegisterConsumerJSONBody

// SignInConsumerJSONRequestBody defines body for SignInConsumer for application/json ContentType.
type SignInConsumerJSONRequestBody SignInConsumerJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (POST /addresses)
	AddConsumerAddress(w http.ResponseWriter, r *http.Request)

	// (DELETE /addresses/{consumerAddressID})
	RemoveConsumerAddress(w http.ResponseWriter, r *http.Request, consumerAddressID ConsumerAddressID)

	// (GET /addresses/{consumerAddressID})
	GetConsumerAddress(w http.ResponseWriter, r *http.Request, consumerAddressID ConsumerAddressID)

	// (PUT /addresses/{consumerAddressID})
	UpdateConsumerAddress(w http.ResponseWriter, r *http.Request, consumerAddressID ConsumerAddressID)

	// (GET /consumer)
	GetConsumer(w http.ResponseWriter, r *http.Request)

	// (POST /orders)
	CreateOrder(w http.ResponseWriter, r *http.Request)

	// (GET /orders/history)
	SearchOrderHistories(w http.ResponseWriter, r *http.Request, params SearchOrderHistoriesParams)

	// (GET /orders/{orderID})
	GetOrder(w http.ResponseWriter, r *http.Request, orderID OrderID)

	// (PUT /orders/{orderID}/cancel)
	CancelOrder(w http.ResponseWriter, r *http.Request, orderID OrderID)

	// (PUT /orders/{orderID}/revise)
	ReviseOrder(w http.ResponseWriter, r *http.Request, orderID OrderID)

	// (POST /register)
	RegisterConsumer(w http.ResponseWriter, r *http.Request)

	// (GET /restaurants/{restaurantID})
	GetRestaurant(w http.ResponseWriter, r *http.Request, restaurantID RestaurantID)

	// (POST /signin)
	SignInConsumer(w http.ResponseWriter, r *http.Request)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// AddConsumerAddress operation middleware
func (siw *ServerInterfaceWrapper) AddConsumerAddress(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddConsumerAddress(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RemoveConsumerAddress operation middleware
func (siw *ServerInterfaceWrapper) RemoveConsumerAddress(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "consumerAddressID" -------------
	var consumerAddressID ConsumerAddressID

	err = runtime.BindStyledParameter("simple", false, "consumerAddressID", chi.URLParam(r, "consumerAddressID"), &consumerAddressID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter consumerAddressID: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RemoveConsumerAddress(w, r, consumerAddressID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetConsumerAddress operation middleware
func (siw *ServerInterfaceWrapper) GetConsumerAddress(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "consumerAddressID" -------------
	var consumerAddressID ConsumerAddressID

	err = runtime.BindStyledParameter("simple", false, "consumerAddressID", chi.URLParam(r, "consumerAddressID"), &consumerAddressID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter consumerAddressID: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetConsumerAddress(w, r, consumerAddressID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateConsumerAddress operation middleware
func (siw *ServerInterfaceWrapper) UpdateConsumerAddress(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "consumerAddressID" -------------
	var consumerAddressID ConsumerAddressID

	err = runtime.BindStyledParameter("simple", false, "consumerAddressID", chi.URLParam(r, "consumerAddressID"), &consumerAddressID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter consumerAddressID: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateConsumerAddress(w, r, consumerAddressID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetConsumer operation middleware
func (siw *ServerInterfaceWrapper) GetConsumer(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetConsumer(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateOrder operation middleware
func (siw *ServerInterfaceWrapper) CreateOrder(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateOrder(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SearchOrderHistories operation middleware
func (siw *ServerInterfaceWrapper) SearchOrderHistories(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchOrderHistoriesParams

	// ------------- Optional query parameter "filter" -------------
	if paramValue := r.URL.Query().Get("filter"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("deepObject", true, false, "filter", r.URL.Query(), &params.Filter)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter filter: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := r.URL.Query().Get("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", r.URL.Query(), &params.Next)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter next: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SearchOrderHistories(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetOrder operation middleware
func (siw *ServerInterfaceWrapper) GetOrder(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "orderID" -------------
	var orderID OrderID

	err = runtime.BindStyledParameter("simple", false, "orderID", chi.URLParam(r, "orderID"), &orderID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter orderID: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetOrder(w, r, orderID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CancelOrder operation middleware
func (siw *ServerInterfaceWrapper) CancelOrder(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "orderID" -------------
	var orderID OrderID

	err = runtime.BindStyledParameter("simple", false, "orderID", chi.URLParam(r, "orderID"), &orderID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter orderID: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CancelOrder(w, r, orderID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ReviseOrder operation middleware
func (siw *ServerInterfaceWrapper) ReviseOrder(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "orderID" -------------
	var orderID OrderID

	err = runtime.BindStyledParameter("simple", false, "orderID", chi.URLParam(r, "orderID"), &orderID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter orderID: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ReviseOrder(w, r, orderID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RegisterConsumer operation middleware
func (siw *ServerInterfaceWrapper) RegisterConsumer(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RegisterConsumer(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetRestaurant operation middleware
func (siw *ServerInterfaceWrapper) GetRestaurant(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "restaurantID" -------------
	var restaurantID RestaurantID

	err = runtime.BindStyledParameter("simple", false, "restaurantID", chi.URLParam(r, "restaurantID"), &restaurantID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter restaurantID: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRestaurant(w, r, restaurantID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SignInConsumer operation middleware
func (siw *ServerInterfaceWrapper) SignInConsumer(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SignInConsumer(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL     string
	BaseRouter  chi.Router
	Middlewares []MiddlewareFunc
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/addresses", wrapper.AddConsumerAddress)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/addresses/{consumerAddressID}", wrapper.RemoveConsumerAddress)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/addresses/{consumerAddressID}", wrapper.GetConsumerAddress)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/addresses/{consumerAddressID}", wrapper.UpdateConsumerAddress)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/consumer", wrapper.GetConsumer)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/orders", wrapper.CreateOrder)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/orders/history", wrapper.SearchOrderHistories)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/orders/{orderID}", wrapper.GetOrder)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/orders/{orderID}/cancel", wrapper.CancelOrder)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/orders/{orderID}/revise", wrapper.ReviseOrder)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/register", wrapper.RegisterConsumer)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/restaurants/{restaurantID}", wrapper.GetRestaurant)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/signin", wrapper.SignInConsumer)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	pathPrefix := path.Dir(pathToFile)

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(pathPrefix, "../../../serviceapis/commonapi/spec.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
