// Package main provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.7.0 DO NOT EDIT.
package ports

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	externalRef0 "github.com/stackus/ftgogo/serviceapis/commonapi"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for OrderState.
const (
	OrderStateApprovalPending OrderState = "ApprovalPending"

	OrderStateApproved OrderState = "Approved"

	OrderStateCancelPending OrderState = "CancelPending"

	OrderStateCancelled OrderState = "Cancelled"

	OrderStateRejected OrderState = "Rejected"

	OrderStateRevisionPending OrderState = "RevisionPending"

	OrderStateUnknown OrderState = "Unknown"
)

// Order defines model for Order.
type Order struct {
	OrderId    string     `json:"order_id"`
	OrderTotal int        `json:"order_total"`
	Status     OrderState `json:"status"`
}

// OrderDetail defines model for OrderDetail.
type OrderDetail struct {
	CreatedAt      time.Time  `json:"created_at"`
	OrderId        string     `json:"order_id"`
	RestaurantId   string     `json:"restaurant_id"`
	RestaurantName string     `json:"restaurant_name"`
	Status         OrderState `json:"status"`
}

// OrderState defines model for OrderState.
type OrderState string

// ConsumerAddressID defines model for ConsumerAddressID.
type ConsumerAddressID string

// LimitQuery defines model for LimitQuery.
type LimitQuery int

// NextQuery defines model for NextQuery.
type NextQuery string

// OrderID defines model for OrderID.
type OrderID string

// RestaurantID defines model for RestaurantID.
type RestaurantID string

// ConsumerAddressIDResponse defines model for ConsumerAddressIDResponse.
type ConsumerAddressIDResponse struct {
	AddressId  string `json:"address_id"`
	ConsumerId string `json:"consumer_id"`
}

// ConsumerAddressResponse defines model for ConsumerAddressResponse.
type ConsumerAddressResponse struct {
	Address externalRef0.Address `json:"address"`
}

// ConsumerIDResponse defines model for ConsumerIDResponse.
type ConsumerIDResponse struct {
	Id string `json:"id"`
}

// ConsumerResponse defines model for ConsumerResponse.
type ConsumerResponse struct {
	ConsumerId string `json:"consumer_id"`
	Name       string `json:"name"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Message string `json:"message"`
}

// OrderIDResponse defines model for OrderIDResponse.
type OrderIDResponse struct {
	Id string `json:"id"`
}

// OrderResponse defines model for OrderResponse.
type OrderResponse struct {
	Order Order `json:"order"`
}

// OrderStatusResponse defines model for OrderStatusResponse.
type OrderStatusResponse struct {
	Status OrderState `json:"status"`
}

// RestaurantIDResponse defines model for RestaurantIDResponse.
type RestaurantIDResponse struct {
	Id string `json:"id"`
}

// SearchOrdersResponse defines model for SearchOrdersResponse.
type SearchOrdersResponse struct {
	Next   string        `json:"next"`
	Orders []OrderDetail `json:"orders"`
}

// SignInResponse defines model for SignInResponse.
type SignInResponse struct {
	Token string `json:"token"`
}

// AddConsumerAddressJSONBody defines parameters for AddConsumerAddress.
type AddConsumerAddressJSONBody struct {
	Address externalRef0.Address `json:"address"`
	Name    string               `json:"name"`
}

// UpdateConsumerAddressJSONBody defines parameters for UpdateConsumerAddress.
type UpdateConsumerAddressJSONBody struct {
	Address externalRef0.Address `json:"address"`
}

// SearchOrdersParams defines parameters for SearchOrders.
type SearchOrdersParams struct {

	// search filters
	Filter *struct {
		Keywords *[]string   `json:"keywords,omitempty"`
		Since    *time.Time  `json:"since,omitempty"`
		Status   *OrderState `json:"status,omitempty"`
	} `json:"filter,omitempty"`

	// provide to read the next page of results
	Next *NextQuery `json:"next,omitempty"`

	// provide to set the results page size
	Limit *LimitQuery `json:"limit,omitempty"`
}

// CreateOrderJSONBody defines parameters for CreateOrder.
type CreateOrderJSONBody struct {
	AddressId    string                          `json:"address_id"`
	ConsumerId   string                          `json:"consumer_id"`
	LineItems    externalRef0.MenuItemQuantities `json:"line_items"`
	RestaurantId string                          `json:"restaurant_id"`
}

// ReviseOrderJSONBody defines parameters for ReviseOrder.
type ReviseOrderJSONBody struct {
	RevisedQuantities externalRef0.MenuItemQuantities `json:"revised_quantities"`
}

// RegisterConsumerJSONBody defines parameters for RegisterConsumer.
type RegisterConsumerJSONBody struct {
	Name string `json:"name"`
}

// SignInConsumerJSONBody defines parameters for SignInConsumer.
type SignInConsumerJSONBody struct {
	ConsumerId string `json:"consumer_id"`
}

// AddConsumerAddressJSONRequestBody defines body for AddConsumerAddress for application/json ContentType.
type AddConsumerAddressJSONRequestBody AddConsumerAddressJSONBody

// UpdateConsumerAddressJSONRequestBody defines body for UpdateConsumerAddress for application/json ContentType.
type UpdateConsumerAddressJSONRequestBody UpdateConsumerAddressJSONBody

// CreateOrderJSONRequestBody defines body for CreateOrder for application/json ContentType.
type CreateOrderJSONRequestBody CreateOrderJSONBody

// ReviseOrderJSONRequestBody defines body for ReviseOrder for application/json ContentType.
type ReviseOrderJSONRequestBody ReviseOrderJSONBody

// RegisterConsumerJSONRequestBody defines body for RegisterConsumer for application/json ContentType.
type RegisterConsumerJSONRequestBody RegisterConsumerJSONBody

// SignInConsumerJSONRequestBody defines body for SignInConsumer for application/json ContentType.
type SignInConsumerJSONRequestBody SignInConsumerJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (POST /addresses)
	AddConsumerAddress(w http.ResponseWriter, r *http.Request)

	// (DELETE /addresses/{consumerAddressID})
	RemoveConsumerAddress(w http.ResponseWriter, r *http.Request, consumerAddressID ConsumerAddressID)

	// (GET /addresses/{consumerAddressID})
	GetConsumerAddress(w http.ResponseWriter, r *http.Request, consumerAddressID ConsumerAddressID)

	// (PUT /addresses/{consumerAddressID})
	UpdateConsumerAddress(w http.ResponseWriter, r *http.Request, consumerAddressID ConsumerAddressID)

	// (GET /consumer)
	GetConsumer(w http.ResponseWriter, r *http.Request)

	// (GET /orders)
	SearchOrders(w http.ResponseWriter, r *http.Request, params SearchOrdersParams)

	// (POST /orders)
	CreateOrder(w http.ResponseWriter, r *http.Request)

	// (GET /orders/{orderID})
	GetOrder(w http.ResponseWriter, r *http.Request, orderID OrderID)

	// (PUT /orders/{orderID}/cancel)
	CancelOrder(w http.ResponseWriter, r *http.Request, orderID OrderID)

	// (PUT /orders/{orderID}/revise)
	ReviseOrder(w http.ResponseWriter, r *http.Request, orderID OrderID)

	// (POST /register)
	RegisterConsumer(w http.ResponseWriter, r *http.Request)

	// (GET /restaurants/{restaurantID})
	GetRestaurant(w http.ResponseWriter, r *http.Request, restaurantID RestaurantID)

	// (POST /signin)
	SignInConsumer(w http.ResponseWriter, r *http.Request)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// AddConsumerAddress operation middleware
func (siw *ServerInterfaceWrapper) AddConsumerAddress(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddConsumerAddress(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RemoveConsumerAddress operation middleware
func (siw *ServerInterfaceWrapper) RemoveConsumerAddress(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "consumerAddressID" -------------
	var consumerAddressID ConsumerAddressID

	err = runtime.BindStyledParameter("simple", false, "consumerAddressID", chi.URLParam(r, "consumerAddressID"), &consumerAddressID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter consumerAddressID: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RemoveConsumerAddress(w, r, consumerAddressID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetConsumerAddress operation middleware
func (siw *ServerInterfaceWrapper) GetConsumerAddress(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "consumerAddressID" -------------
	var consumerAddressID ConsumerAddressID

	err = runtime.BindStyledParameter("simple", false, "consumerAddressID", chi.URLParam(r, "consumerAddressID"), &consumerAddressID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter consumerAddressID: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetConsumerAddress(w, r, consumerAddressID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateConsumerAddress operation middleware
func (siw *ServerInterfaceWrapper) UpdateConsumerAddress(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "consumerAddressID" -------------
	var consumerAddressID ConsumerAddressID

	err = runtime.BindStyledParameter("simple", false, "consumerAddressID", chi.URLParam(r, "consumerAddressID"), &consumerAddressID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter consumerAddressID: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateConsumerAddress(w, r, consumerAddressID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetConsumer operation middleware
func (siw *ServerInterfaceWrapper) GetConsumer(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetConsumer(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SearchOrders operation middleware
func (siw *ServerInterfaceWrapper) SearchOrders(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchOrdersParams

	// ------------- Optional query parameter "filter" -------------
	if paramValue := r.URL.Query().Get("filter"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("deepObject", true, false, "filter", r.URL.Query(), &params.Filter)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter filter: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := r.URL.Query().Get("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", r.URL.Query(), &params.Next)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter next: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SearchOrders(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateOrder operation middleware
func (siw *ServerInterfaceWrapper) CreateOrder(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateOrder(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetOrder operation middleware
func (siw *ServerInterfaceWrapper) GetOrder(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "orderID" -------------
	var orderID OrderID

	err = runtime.BindStyledParameter("simple", false, "orderID", chi.URLParam(r, "orderID"), &orderID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter orderID: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetOrder(w, r, orderID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CancelOrder operation middleware
func (siw *ServerInterfaceWrapper) CancelOrder(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "orderID" -------------
	var orderID OrderID

	err = runtime.BindStyledParameter("simple", false, "orderID", chi.URLParam(r, "orderID"), &orderID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter orderID: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CancelOrder(w, r, orderID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ReviseOrder operation middleware
func (siw *ServerInterfaceWrapper) ReviseOrder(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "orderID" -------------
	var orderID OrderID

	err = runtime.BindStyledParameter("simple", false, "orderID", chi.URLParam(r, "orderID"), &orderID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter orderID: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ReviseOrder(w, r, orderID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RegisterConsumer operation middleware
func (siw *ServerInterfaceWrapper) RegisterConsumer(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RegisterConsumer(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetRestaurant operation middleware
func (siw *ServerInterfaceWrapper) GetRestaurant(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "restaurantID" -------------
	var restaurantID RestaurantID

	err = runtime.BindStyledParameter("simple", false, "restaurantID", chi.URLParam(r, "restaurantID"), &restaurantID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter restaurantID: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRestaurant(w, r, restaurantID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SignInConsumer operation middleware
func (siw *ServerInterfaceWrapper) SignInConsumer(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SignInConsumer(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL     string
	BaseRouter  chi.Router
	Middlewares []MiddlewareFunc
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/addresses", wrapper.AddConsumerAddress)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/addresses/{consumerAddressID}", wrapper.RemoveConsumerAddress)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/addresses/{consumerAddressID}", wrapper.GetConsumerAddress)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/addresses/{consumerAddressID}", wrapper.UpdateConsumerAddress)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/consumer", wrapper.GetConsumer)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/orders", wrapper.SearchOrders)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/orders", wrapper.CreateOrder)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/orders/{orderID}", wrapper.GetOrder)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/orders/{orderID}/cancel", wrapper.CancelOrder)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/orders/{orderID}/revise", wrapper.ReviseOrder)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/register", wrapper.RegisterConsumer)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/restaurants/{restaurantID}", wrapper.GetRestaurant)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/signin", wrapper.SignInConsumer)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"3aTLDzAlAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	pathPrefix := path.Dir(pathToFile)

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(pathPrefix, "../../../serviceapis/commonapi/spec.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
